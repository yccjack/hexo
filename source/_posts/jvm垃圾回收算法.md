---
title: jvm垃圾回收算法
cover: https://mysticalyu.gitee.io/pic/img_min/yueyang.jpg
categories: jvm
tags: [jvm,java] 
date: 2020-09-28
description: jvm的垃圾回收算法总结
---



# 垃圾回收



Java堆内存分为新生代和老年代:新生代主要存储短生命周期的对象,适合使用复制算法进行垃圾回收;老年代主要存储长生命周期的对象,适合使用标记整理算法进行垃圾回收因此,JVM针对新生代和老年代分别提供了多种不同的垃圾收集器,针对新生代提供的垃圾收集器有串行ParNew并行清除,针对老年代提供的垃圾收集器有串行老并行老CMS,还有针对不同区域的G1分区收集算法,如图。

![image-20201008143352344](https://gitee.com/MysticalYu/pic/raw/master/hexo/image-20201008143352344.png)

## Serial 垃圾收集器:单线程,复制算法 

Serial 垃圾收集器基于复制算法实现,它是一个单线程收集器,在它正在进行垃圾收集时,必须暂停其他所有工作线程,直到垃圾收集结束 Serial 垃圾收集器采用了复制算法,简单 高效,对于单 CPU 运行环境来说,没有线程交互开销,可以获得最高的单线程垃圾收集效率,因此 Serial 垃圾收集器是 Java 虚拟机运行在 Client 模式下的新生代的默认垃圾收集器。

## ParNew 垃圾收集器:多线程,复制算法 

ParNew 垃圾收集器是 Serial 垃圾收集器的多线程实现,同样采用了复制算法,它采用多线程模式工作,除此之外和 Serial 收集器几乎一样 ParNew 垃圾收集器在垃圾收集过程中会暂停所有其他工作线程,是 Java 虚拟机运行在 Server 模式下的新生代的默认垃圾收集器 。

ParNew 垃圾收集器默认开启与 CPU 同等数量的线程进行垃圾回收,在 Java 应用启动时可通过-XX:ParallelGCThreads 参数调节 ParNew 垃圾收集器的工作线程数。

## Parallel Scavenge 垃圾收集器:多线程,复制算法 

Parallel Scavenge 收集器是为提高新生代垃圾收集效率而设计的垃圾收集器,基于多线程复制算法实现,在系统吞吐量上有很大的优化,可以更高效地利用 CPU 尽快完成垃圾回收任务。

 Parallel Scavenge 通过自适应调节策略提高系统吞吐量,提供了三个参数用于调节 控制垃圾回收的停顿时间及吞吐量,分别是控制最大垃圾收集停顿时间的-XX:MaxGCPauseMillis 参数,控制吞吐量大小的-XX:GCTimeRatio 参数和控制自适应调节策略开启与否的 UseAdaptiveSizePolicy 参数。

## Serial Old 垃圾收集器:单线程,标记整理算法

 Serial Old 垃圾收集器是 Serial 垃圾收集器的老年代实现,同 Serial 一样采用单线程执行,不同的是,Serial Old 针对老年代长生命周期的特点基于标记整理算法实现 Serial Old 垃圾收集器是 JVM 运行在 Client 模式下的老年代的默认垃圾收集器。

 新生代的 Serial 垃圾收集器和老年代的 Serial Old 垃圾收集器可搭配使用,分别针对 JVM 的新生代和老年代进行垃圾回收,其垃圾收集过程如图所示 在新生代采用 Serial 垃圾收集器基于复制算法进行垃圾回收,未被其回收的对象在老年代被 Serial Old 垃圾收集器基于标记整理算法进行垃圾回收。

![image-20201008144232536](https://gitee.com/MysticalYu/pic/raw/master/hexo/image-20201008144232536.png)

## Parallel Old 垃圾收集器:多线程,标记整理算法

 Parallel Old 垃圾收集器采用多线程并发进行垃圾回收,它根据老年代长生命周期的特点,基于多线程的标记整理算法实现 Parallel Old 垃圾收集器在设计上优先考虑系统吞吐量,其次考虑停顿时间等因素,如果系统对吞吐量的要求较高,则可以优先考虑新生代的 Parallel Scavenge 垃圾收集器和老年代的 Parallel Old 垃圾收集器的配合使用。

 新生代的 Parallel Scavenge 垃圾收集器和老年代的 Parallel Old 垃圾收集器的搭配运行过程如图所示 新生代基于 Parallel Scavenge 垃圾收集器的复制算法进行垃圾回收,老年代基于 Parallel Old 垃圾收集器的标记整理算法进行垃圾回收。

![image-20201008144420468](https://gitee.com/MysticalYu/pic/raw/master/hexo/image-20201008144420468.png)

## CMS垃圾回收器

CMS(Concurrent Mark Sweep)垃圾收集器是为老年代设计的垃圾收集器,其主要目的是达到最短的垃圾回收停顿时间,基于线程的标记清除算法实现,以便在多线程并发环境下以最短的垃圾收集停顿时间提高系统的稳定性。

CMS 的工作机制相对复杂,垃圾回收过程包含如下 4 个步骤

(1)初始标记:只标记和 GC Roots 直接关联的对象,速度很快,需要暂停所有工作线程 。

(2)并发标记:和用户线程一起工作,执行 GC Roots 跟踪标记过程,不需要暂停工作线程 。

(3)重新标记:在并发标记过程中用户线程继续运行,导致在垃圾回收过程中部分对象的状态发生变化,为了确保这部分对象的状态正确性,需要对其重新标记并暂停工作线程 。

(4)并发清除:和用户线程一起工作,执行清除 GC Roots 不可达对象的任务,不需要暂停工作线程。

CMS 垃圾收集器在和用户线程一起工作时(并发标记和并发清除)不需要暂停用户线程,有效缩短了垃圾回收时系统的停顿时间,同时由于 CMS 垃圾收集器和用户线程一起工作,因此其并行度和效率也有很大提升 CMS 收集器的工作流程如图。

![image-20201008144542197](https://gitee.com/MysticalYu/pic/raw/master/hexo/image-20201008144542197.png)

G1 垃圾收集器 G1(Garbage First)垃圾收集器为了避免全区域垃圾收集引起的系统停顿,将堆内存划分为大小固定的几个独立区域,独立使用这些区域的内存资源并且跟踪这些区域的垃圾收集进度,同时在后台维护一个优先级列表,在垃圾回收过程中根据系统允许的最长垃圾收集时间,优先回收垃圾最多的区域 G1 垃圾收集器通过内存区域独立划分使用和根据不同优先级回收各区域垃圾的机制,确保了 G1 垃圾收集器在有限时间内获得最高的垃圾收集效率 相对于 CMS 收集器,G1 垃圾收集器两个突出的改进 

- 基于标记整理算法,不产生内存碎片 。
- 可以精确地控制停顿时间,在不牺牲吞吐量的前提下实现短停顿垃圾回收。