---
title: 操作系统-分段存储和段页存储管理
cover: https://mysticalyu.gitee.io/pic/img_min/gyu-bin-yun-screenshot011.jpg
date: 2020-09-27
categories: 操做系统
tags: [操做系统] 
description: 操作系统-分段存储和段页存储管理
---



# 分段存储管理的基本原理

为了提供内存空间利用率，存储管理从固定分区分配发展到可变分区分配，再发展到分页存储管理。但从用户角度看，以上几种管理方式都存在着自身局限性，难以满足用户在编程和使用上的多方面需求。事实上，程序大多采用分段结构，一个程序可以由主程序段、子程序段和数据段等组成，每个段都从逻辑地址 0 开始编制，有各自的名字和长度，并实现不同的功能。



## 分段存储：

 1．实现原理

在分段存储管理中，系统将程序的逻辑地址空间分成若干个逻辑分段，如主程序段、子程序段、数据段和工作区段等，每个分段都是一组逻辑意义完整的信息集合，且有各自的段名或段号，即在逻辑上是各自独立的。每个段都是从 0 开始编址的一维连续地址空间，其长度由段自身包含的逻辑信息长度决定，所以各段的长度可以不同，整个程序的所有段则构成了二维地址空间。在为程序分配内存时，允许以段为单位将程序离散地装入相邻或不相邻的内存空间中，而每个段则占用一段连续的内存区域，系统通过地址转换机构，将段的逻辑地址转换为实际的内存物理地址，从而使程序能够正确执行。

![image-20200927081138694](https://gitee.com/MysticalYu/pic/raw/master/hexo/image-20200927081138694.png)

 2．逻辑地址结构

在分段存储管理中，由于程序的地址空间被分成若干个段，因此程序的逻辑地址是二维的，即程序的逻辑地址由段号（段名）和段内地址两部分组成）。段号和段内地址都是从 0 开始编址，段号范围决定了程序中最多允许有多少个段，段内地址的范围则决定了每个段的最大长度。在图示的地址结构中，一个程序最多允许 256（28）个段，每个段的最大长度为 16MB（224）。

![image-20200927081357129](https://gitee.com/MysticalYu/pic/raw/master/hexo/image-20200927081357129.png)

在现代操作系统中，绝大多数编译程序都支持分段方式，因此用户程序如何分段这个问题对用户来说是透明的，即可以由编译程序根据源程序的情况自动产生若干个段。

 3．段表

在分段存储管理中，程序的各段以离散分配方式装入到内存中相邻或不相邻的空闲分区，即内存中各段之间可以不连续，但每个段在所装入的分区中是连续的。为了使程序正常运行，必须要找到每个逻辑段在内存中具体的物理存储位置，即实现将二维逻辑地址转换为一维物理地址，这项工作通过段映射表（简称段表）来完成。系统为每个程序建立了一个段表，程序的每个段在段表中有一个段表项，这个段表项记录了该段的段名（段号），该段在内存中的起始地址（内存始址）以及该段的长度（段长）等信息。

![image-20200927081428490](https://gitee.com/MysticalYu/pic/raw/master/hexo/image-20200927081428490.png)

## 地址转换与存储保护

1．地址转换

分段存储管理也涉及地址转换问题，为了实现段的逻辑地址到内存物理地址的转换，系统为每个程序设置了一个段表，地址转换机构则通过段表来完成逻辑段到内存物理分区的映射。由于段表一般存放在内存中，因此系统使用了段表控制寄存器来存放运行程序（进程）的段表始址（段表在内存中的起始地址）和段表长度（程序的逻辑地址空间中从段号 0 开始划分出的最大段号）。进行地址转换时，先通过段表控制寄存器中存放的段表始址找到段表，然后再从段表中找到对应的段表项来完成逻辑段到内存物理分区的映射。

![image-20200927081520616](https://gitee.com/MysticalYu/pic/raw/master/hexo/image-20200927081520616.png)

在地址转换过程中，系统首先将逻辑地址中的段号与段表控制寄存器中的段表长度（程序中允许的最大段号）进行比较，若超过了段表长度，则产生一个段越界中断信号；否则，将段表控制寄存器中的段表始址和逻辑地址中的段号（在段表中又表示段表项的相对位移）相加，找到该段在段表中对应的段表项，并从此段表项中获得该段映射到内存中的起始地址（内存始址）。然后再根据逻辑地址中的段内地址，是否大于段表项中的段长，来判断是否产生段内地址越界，若大于，则产生地址越界中断信号；若不大于（段内地址未越界），则将已获得的该段在内存中的起始地址（内存始址）与逻辑地址中的段内地址相加，得到要访问的内存物理地址。

上过地址转换过程和分页存储相似，一次转换最少需要访问内存两次，所有分段解决的方法与分页存储管理类似,也是设置联想存储器(快表),过程详见：

[分页存储管理](https://www.gschaos.club/%E6%93%8D%E5%81%9A%E7%B3%BB%E7%BB%9F-%E5%90%8C%E6%AD%A5%E5%92%8C%E9%80%9A%E4%BF%A1/) 后半部分。



## 段页式存储管理的基本原理

段页式存储管理结合了分段存储管理和分页存储管理的优点，在为程序分配内存空间时，采用的是「各段之间按分段存储管理进行分配，每个段内部则按分页存储管理进行分配」的原则。内存空间的管理则只按页的大小划分为若干个的物理块，并且内存中所有物理块从 0 开始顺序编号。在为程序分配内存空间时，允许以页为单位，一次性将一个程序中每个段的所有页装入内存若干相邻或不相邻的物理块中。在段页式存储管理中，由于对段又进行了分页，即逻辑地址空间中的最小单位是页，内存空间也被划分为与页大小相等的若干物理块。分配以页为单位进行，因此每个段包含的所有页在内存中也实现了离散存储。

1．逻辑地址结构

在段页式存储管理中，一个程序的逻辑地址结构由段号、段内页号和页内地址这三部分组成，如图 。

![image-20200927083658716](https://gitee.com/MysticalYu/pic/raw/master/hexo/image-20200927083658716.png)

程序的逻辑地址仍然是一个二维地址空间，用户可见的仍然是段号和段内地址，而地址转换机构，则根据系统要求自动把段内地址分为两部分，高位部分为页号（段内页号），低位部分为页内地址。假定逻辑地址长度为 32 位，若段号占 8 位，段内页号占 12 位，页内地址占 12 位，则一个程序最多允许有 256（28）个段，每段最多允许 4096（212）个页，每页的大小为 4KB（212）。

2．数据结构

为了实现段页式存储管理，系统必须设置以下两种数据结构。

（1）段表。系统为每个程序建立一张段表，程序的每个段在段表中有一个段表项，此段表项记录了该段的页表长度和页表始址（页表在内存中存放的起始地址）。

（2）页表。系统为程序中的每个段都建立一张页表，一个段中的每个页在该段的页表中都有一个页表项，每个页表项记录了一个页的页号及其映射的内存物理块号。

###  地址转换

在段页式存储管理中，指令中的逻辑地址到内存物理地址的转换也是由地址转换机构完成的。在地址转换过程中需要使用段表和页表，而程序的段表和页表通常都存放在内存中。因此地址转换机构配置了一个段表控制寄存器，用来记录运行程序的段表长度和段表始址（段表存放在内存的起始地址）。段页式存储管理方式的地址转换过程如图 所示。地址转换时，地址转换机构首先将逻辑地址中的段号与段表控制寄存器中的段表长度（程序中允许的最大段号）比较，若段号大于段表长度，则产生段越界中断；否则未越界，这时利用段表控制寄存器中的段表始址和逻辑地址中的段号（表示段表项的相对位移）相加，获得该段号所对应的段表项在段表中的位置，找到该段表项后，从中获得该段的页表在内存中存放的起始地址（页表始址）和页表长度。若逻辑地址中的段内页号（页号）大于该段表项中的页表长度（该段所允许的最大页号），则产生页越界中断；否则，在该段表项中取出页表始址和逻辑地址中的段内页号（页表项的相对位移）相加，获得该段的页表中该页号（段内页号）对应的页表项位置，并从此页表项中获得该页号所映射的内存物理块号，最后将此物理块号和逻辑地址中的页内地址拼接（由物理块号替换逻辑地址中的段内页号而页内地址不变），形成要访问的内存物理地址。

对段页式存储管理而言，要完成对内存中某个数据的访问，至少要三次访问内存：第一次访问内存是根据段表控制寄存器中的段表始址加上逻辑地址中的段号（段表项的相对位移）在内存中查找程序的段表找到该段号对应的段表项，并在此段表项中找到该段号所对应的页表在内存中的起始地址（页表始址）；第二次访问内存是根据页表始址加上逻辑地址中的段内页号到内存中访问页表找到对应的页表项，并从此页表项中找到该页号（段内页号）映射的物理块号，并将该物理块号与逻辑地址中的页内地址拼接，形成要访问的内存物理地址；第三次才是根据这个内存物理地址去访问该地址中存放的数据。显然，内存访问次数的增加会使计算机的运行速度受到很大的影响。

![image-20200927083817463](https://gitee.com/MysticalYu/pic/raw/master/hexo/image-20200927083817463.png)

为了提高地址转换的速度，在段页式存储管理系统中，设置联想存储器（快表）显得尤为重要。快表中存放了当前执行程序最常用的段号、页号（段内页号）和映射的内存物理块号。当要访问内存中某个数据时，可以先根据段号、页号在快表中查找是否有与之对应的表项，若找到，则不必再到内存中去访问段表和页表，直接将快表中找到的表项中所映射的物理块号，与逻辑地址中的页内地址拼接成要访问的内存物理地址；若快表中未找到相应的表项，则仍需两次访问内存（一次访问段表，一次访问页表）来获得内存物理地址，并同时将此次访问的段号、页号与所映射的物理块号填入到快表中；若快表已满，则还需在填入前根据某种算法淘汰快表中的某个表项。