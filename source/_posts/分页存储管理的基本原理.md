---
title: 分页存储管理的基本原理
categories: java
tags: [java,操作系统,分页管理] 
date: 2020-09-07
cover: https://mysticalyu.gitee.io/pic/img/huifeng-huang-pose-final.jpg

---

![](https://mysticalyu.gitee.io/pic/img/huifeng-huang-pose-final.jpg)



 <!-- more -->



## 分页存储管理的基本原理

### 1．实现原理

在分页存储管理中，一个程序的逻辑地址空间被划分成若干个大小相等的区域，每个区域称为页或页面，并且程序地址空间中所有的页从 0 开始顺序编号。相应地，内存物理地址空间也按同样方式划分成与页大小相同的区域，每个区域称为物理块或页框，与页一样内存空间中的所有物理块也从 0 开始顺序编号。在为程序分配内存时，允许以页为单位将程序的各个页，分别装入内存中相邻或不相邻的物理块中（如图 4-18 所示）。由于程序的最后一页往往不能装满分配给它的物理块，于是会有一定程度的内存空间浪费，这部分被浪费的内存空间称为页内碎片。

分页系统中页的选择对系统性能有重要影响。若页划分得过小，虽然可以有效减少页内碎片，并提高内存利用率，但会导致每个进程需要更多的页，这样会使分页系统中用于页管理的页表增大，而占用更多的内存空间。若页划分得过大，虽然可以减少页表大小，并提高页的置换速度，但会导致页内碎片增大，而且当一个页大到能装下一个程序时就退化为分区存储管理了。因此页的大小应适中，分页系统中页的大小取决于机器的地址结构，一般设置为 2 的整数幂，通常为 512B～8KB。

图 4-18　程序以页为单位离散装入内存示意

### 2．逻辑地址结构

在分页存储管理中，程序中的逻辑地址被转换为页号和页内地址。这个转换工作在程序执行时由系统硬件自动完成，整个过程对用户透明。因此用户编程时不需要知道逻辑地址与页号和页内地址的对应关系，只需要使用一维的逻辑地址。

程序的一维逻辑地址空间经过系统硬件自动分页后，形成「页号 + 页内地址」的地址结构（如图 4-19 所示）。在如图 4-19 所示的地址结构中，逻辑地址通过页号和页内地址来共同表示。其中，0～11 位是页内地址，即每个页的大小是 4KB；12～31 位是页号，即地址空间最多允许有 1M 个页。一维逻辑地址与页号和页内地址的关系是（注：页长即一页的大小）

图 4-19　分页存储管理中逻辑地址结构

一维逻辑地址 = 页号 × 页长 + 页内地址

### 3．数据结构

为了实现分页存储管理，系统主要设置了以下两种表格。

- （1）页表

在分页系统中，允许程序所有的页以离散方式分别存储在内存不同的物理块里，为了使程序能够正确运行，必须在内存空间中找到存放每个页的物理块。因此操作系统为每个程序（进程）建立了一张页映射表，简称页表（Page Table），用来存储页号及其映射（装入）的内存物理块号。最简单的页表由页号及其映射的物理块号组成（如图 4-20 所示）。由于页表的长度由程序所拥有页的个数决定，故每个程序的页表长度通常不同。

- （2）内存分配表

为了正确地将一个页装入到内存的某一物理块中，就必须知道内存中所有物理块的使用情况，因此系统建立一张内存分配表来记录内存中物理块的分配情况。由于每个物理块的大小相同且不会改变大小，因此最简单的办法是用一张位示图（Bitmap）来构成内存分配表。位示图是指在内存中开辟若干个字，它的每一位与内存中的一个物理块相对应。每一位的值可以是 0 或 1，当取值为 0 时，表示对应的物理块空闲；当取值为 1 时，表示对应的物理块已分配。此外，在位示图中增加一个字节，来记录内存当前空闲物理块的总数（如图 4-21 所示）。

图 4-20　页表的使用示意

图 4-21　位示图