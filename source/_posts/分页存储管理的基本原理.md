---
title: 分页存储管理的基本原理
categories: java
tags: [java,操作系统,分页管理] 
date: 2020-09-07
cover: https://mysticalyu.gitee.io/pic/img/huifeng-huang-pose-final.jpg

---

![](https://mysticalyu.gitee.io/pic/img/huifeng-huang-pose-final.jpg)



 <!-- more -->



## 

## 逻辑地址和物理地址

-  逻辑地址。用户源程序经编译、链接后得到可装入程序。由于无法预先知道程序装入内存的具体位置，因此不可能在程序中直接使用内存地址，只能暂定程序的起始地址为 0。这样，程序中指令和数据的地址都是相对 0 这个起始地址进行计算的，按照这种方法确定的地址称为逻辑地址或相对地址。一般情况下，目标模块（程序）和装入模块（程序）中的地址都是逻辑地址。

- 逻辑地址空间。一个目标模块（程序）或装入模块（程序）的所有逻辑地址的集合，称为逻辑地址空间或相对地址空间。

- 物理地址。内存中实际存储单元的地址称为物理地址，物理地址也称为绝对地址或内存地址。为了使程序装入内存后能够正常运行，就必须将程序代码中的逻辑地址转换为物理地址，这个转换操作称为地址转换。

- 物理地址空间。内存中全部存储单元的物理地址集合称为物理地址空间、绝对地址空间或内存地址空间。由于每个内存单元都有唯一的内存地址编号，因此物理地址空间是一个一维的线性空间。要使装入内存的程序后能够正常运行、互不干扰，就必须将不同程序装入到内存空间的不同区域。

- 虚拟地址空间。CPU 支持的地址范围一般远大于机器实际内存的大小，对于多出来的那部分地址（没有对应的实际内存）程序仍然可能使用，我们将程序能够使用的整个地址范围称为虚拟地址空间。如 Windows XP 采用 32 位地址结构，每个用户进程的虚拟地址空间为 4GB（232），但可能实际内存只有 2GB。虚拟地址空间中的某个地址称为虚拟地址，而用户进程的虚拟地址就是前面所说的逻辑地址。



## 分页存储管理的基本原理



### 1．实现原理

在分页存储管理中，一个程序的逻辑地址空间被划分成若干个大小相等的区域，每个区域称为页或页面，并且程序地址空间中所有的页从 0 开始顺序编号。相应地，内存物理地址空间也按同样方式划分成与页大小相同的区域，每个区域称为物理块或页框，与页一样内存空间中的所有物理块也从 0 开始顺序编号。在为程序分配内存时，允许以页为单位将程序的各个页，分别装入内存中相邻或不相邻的物理块中。由于程序的最后一页往往不能装满分配给它的物理块，于是会有一定程度的内存空间浪费，这部分被浪费的内存空间称为页内碎片。

分页系统中页的选择对系统性能有重要影响。若页划分得过小，虽然可以有效减少页内碎片，并提高内存利用率，但会导致每个进程需要更多的页，这样会使分页系统中用于页管理的页表增大，而占用更多的内存空间。若页划分得过大，虽然可以减少页表大小，并提高页的置换速度，但会导致页内碎片增大，而且当一个页大到能装下一个程序时就退化为分区存储管理了。因此页的大小应适中，分页系统中页的大小取决于机器的地址结构，一般设置为 2 的整数幂，通常为 512B～8KB。

![image-20200917080339283](https://gitee.com/MysticalYu/pic/raw/master/hexo/image-20200917080339283.png)

### 2．逻辑地址结构

在分页存储管理中，程序中的逻辑地址被转换为页号和页内地址。这个转换工作在程序执行时由系统硬件自动完成，整个过程对用户透明。因此用户编程时不需要知道逻辑地址与页号和页内地址的对应关系，只需要使用一维的逻辑地址。



程序的一维逻辑地址空间经过系统硬件自动分页后，形成「页号 + 页内地址」的地址结构。在图 所示的地址结构中，逻辑地址通过页号和页内地址来共同表示。其中，0～11 位是页内地址，即每个页的大小是 4KB；12～31 位是页号，即地址空间最多允许有 1M 个页。一维逻辑地址与页号和页内地址的关系是（注：页长即一页的大小）



一维逻辑地址 = 页号 × 页长 + 页内地址

![image-20200917080459968](https://gitee.com/MysticalYu/pic/raw/master/hexo/image-20200917080459968.png)



### 3．数据结构

为了实现分页存储管理，系统主要设置了以下两种表格。

- （1）页表

在分页系统中，允许程序所有的页以离散方式分别存储在内存不同的物理块里，为了使程序能够正确运行，必须在内存空间中找到存放每个页的物理块。因此操作系统为每个程序（进程）建立了一张页映射表，简称页表（Page Table），用来存储页号及其映射（装入）的内存物理块号。最简单的页表由页号及其映射的物理块号组成。由于页表的长度由程序所拥有页的个数决定，故每个程序的页表长度通常不同。

![image-20200917080632378](https://gitee.com/MysticalYu/pic/raw/master/hexo/image-20200917080632378.png)

- （2）内存分配表

为了正确地将一个页装入到内存的某一物理块中，就必须知道内存中所有物理块的使用情况，因此系统建立一张内存分配表来记录内存中物理块的分配情况。由于每个物理块的大小相同且不会改变大小，因此最简单的办法是用一张位示图（Bitmap）来构成内存分配表。位示图是指在内存中开辟若干个字，它的每一位与内存中的一个物理块相对应。每一位的值可以是 0 或 1，当取值为 0 时，表示对应的物理块空闲；当取值为 1 时，表示对应的物理块已分配。此外，在位示图中增加一个字节，来记录内存当前空闲物理块的总数。

![image-20200917080641623](https://gitee.com/MysticalYu/pic/raw/master/hexo/image-20200917080641623.png)

### 4. 地址保护

1. 基本地址转换

在分页存储管理中,系统为每个程序建立了一张页表并存放于内存中 当程序被装入内存但尚未运行时,页表始址(页表在内存中的起始地址)和页表长度(程序逻辑地址空间从页号 0 开始划分出的最大页号)等信息被保存到为该程序(进程)创建的 PCB 中,或保存到请求表中 一旦进程调度程序调度该进程运行时,其 PCB 中保存的页表始址和页表长度信息(或请求表中这两个的信息)便被装入到页表控制寄存器中,基本地址转换过程如图 所示

![image-20200917080749404](https://gitee.com/MysticalYu/pic/raw/master/hexo/image-20200917080749404.png)





从基本地址转换过程可知  **物理地址 = 物理块号 页长 + 页内地址**,由于页表驻留在内存,因此当 CPU 依据指令中的逻辑地址进行操作时,至少要两次访问内存

为了提高地址转换的速度,一种行之有效的方法是在地址转换机构中,增加一个具备并行查找能力的高速缓冲寄存器,又称联想存储器(Associative Memory)来构成一张快表,快表中保存着当前运行进程最常用的页号及其映射的物理块号

2. 具有快表的地址转换

在快表中查找和在内存中查找是同时进行的,只不过在内存页表中查找的速度要慢一些,当快表中找到含有该页号的页表项时,则终止内存页表的查找。

由于成本的关系,快表不可能做得很大,通常只存放 32~1024 个页表项 据统计,从快表中能找到所需页表项的概率可达 90% 以上。

![image-20200917080941889](https://gitee.com/MysticalYu/pic/raw/master/hexo/image-20200917080941889.png)

3. 页的保护

   页的保护分为两个方面:一是在逻辑地址转换成物理地址时的保护,通过页号与页表长度的比较防止地址越界;二是在实现信息共享时,对共享信息的保护 通常是在页表中增加一些标志位来设置存取控制字段,一般设置只读 读写 读和执行等权限 如果某进程试图去执行一个只允许读的内存物理块,系统就会发出访问性中断。

   